---
layout: guide
title: Index API
cat: guide
sidebar: reference_api
---

p. The index API adds or updates a typed JSON document in a specific index, making it searchable. The following example inserts the JSON document into the "twitter" index, under a type called "tweet" with an id of 1:

<pre class="prettyprint">
$ curl -XPUT 'http://localhost:9200/twitter/tweet/1' -d '{
    "user" : "kimchy",
    "post_date" : "2009-11-15T14:12:12",
    "message" : "trying out Elastic Search"
}'
</pre>

p. The result of the above index operation is:

<pre class="prettyprint lang-js">
{
    "ok" : true,
    "_index" : "twitter",
    "_type" : "tweet",
    "_id" : "1"
}
</pre>

h1. Automatic Index Creation

p. The index operation automatically creates an index if it has not been created before (check out the "create index API":admin-indices-create-index.html for manually creating an index), and also automatically creates a dynamic type mapping for the specific type if one has not yet been created (check out the "put mapping":admin-indices-put-mapping.html API for manually creating a type mapping).

p. The mapping itself is very flexible and is schema-free. New fields and objects will automatically be added to the mapping definition of the type specified. Check out the "mapping":/guide/reference/mapping section for more information on mapping definitions.

p. Though explained on the "mapping":/guide/reference/mapping section, its important to note that the format of the JSON document can also include the type (very handy when using JSON mappers), for example:

<pre class="prettyprint">
$ curl -XPUT 'http://localhost:9200/twitter/tweet/1' -d '{
    "tweet" : {
        "user" : "kimchy",
        "post_date" : "2009-11-15T14:12:12",
        "message" : "trying out Elastic Search"
    }
}'
</pre>

h1. Versioning

p. Each indexed document is given a version number. The associated @version@ number is returned as part of the response to the index API request. The index API optionally allows for "optimistic concurrency control":http://en.wikipedia.org/wiki/Optimistic_concurrency_control when the @version@ parameter is specified. This will control the version of the document the operation is intended to be executed against. A good example of a use case for versioning is performing a transactional read-then-update. Specifying a @version@ from the document initially read ensures no changes have happened in the meantime (when reading, make sure to set the @preference@ to @_primary@). For example:

<pre class="prettyprint">
curl -XPUT 'localhost:9200/twitter/tweet/1?version=2' -d '{
    "message" : "elasticsearch now has versioning support, double cool!"
}'
</pre>

p. *NOTE:* versioning is completely real time, and is not affected by the near real time aspects of search operations. If no version is provided, then the operation is executed without any version checks.

p. By default, internal versioning is used that starts at 1 and increments with each update. Optionally, the version number can be supplemented with an external value (for example, if maintained in a database). To enable this functionality, @version_type@ should be set to @external@. The value provided must be a numeric, integer value greater than 0, and less than around 9.2e+18. When using the external version type, instead of checking for a matching version number, the system checks to see if the version number passed to the index request is greater than or equal to the version of the currently stored document. If true, the document will be indexed and the new version number used. If the value provided is lower than the stored document's version number, a version conflict will occur and the index operation will not fail.

p. A nice side effect is that there is no need to maintain strict ordering of async indexing operations executed a result of changes to a source database, as long as version numbers from the source database are used. Even the simple case of updating the elasticsearch index using data from a database is simplified if external versioning is used, as only the latest version will be used if the index operations are out of order for whatever reason.

h1. Operation Type

p. The index operation also accepts an @op_type@ that can be used to force a @create@ operation, allowing for "put-if-absent" behavior. When @create@ is used, the index operation will fail if a document by that id already exists in the index.

p. Here is an example of using the @op_type@ parameter:

<pre class="prettyprint">
$ curl -XPUT 'http://localhost:9200/twitter/tweet/1?op_type=create' -d '{
    "user" : "kimchy",
    "post_date" : "2009-11-15T14:12:12",
    "message" : "trying out Elastic Search"
}'
</pre>

p. Another option to specify @create@ is to use the following uri:

<pre class="prettyprint">
$ curl -XPUT 'http://localhost:9200/twitter/tweet/1/_create' -d '{
    "user" : "kimchy",
    "post_date" : "2009-11-15T14:12:12",
    "message" : "trying out Elastic Search"
}'
</pre>


h1. Automatic ID Generation

The index operation can be executed without specifying the id. In such a case, an id will be generated automatically. In addition, the @opType@ will automatically be set to @create@. Here is an example (note the *POST* used instead of *PUT*):

<pre class="prettyprint">
$ curl -XPOST 'http://localhost:9200/twitter/tweet/' -d '{
    "user" : "kimchy",
    "post_date" : "2009-11-15T14:12:12",
    "message" : "trying out Elastic Search"
}'
</pre>

p. The result of the above index operation is:

<pre class="prettyprint lang-js">
{
    "ok" : true,
    "_index" : "twitter",
    "_type" : "tweet",
    "_id" : "6a8ca01c-7896-48e9-81cc-9f70661fcb32"
}
</pre>

h1. Routing

p. By default, shard placement &mdash; or @routing@ &mdash; is controlled by using a hash of the document's id value. For more explicit control, the value fed into the hash function used by the router can be directly specified on a per-operation basis using the @route@ parameter. For example:

<pre class="prettyprint">
$ curl -XPOST 'http://localhost:9200/twitter/tweet?routing=kimchy' -d '{
    "user" : "kimchy",
    "post_date" : "2009-11-15T14:12:12",
    "message" : "trying out Elastic Search"
}'
</pre>

p. In the example above, the "tweet" document is routed to a shard based on the @routing@ parameter provided: "kimchy".

p. When setting up explicit mapping, the @_routing@ field can be optionally used to direct the index operation to extract the routing value from the document itself. This does come at the (very minimal) cost of an additional document parsing pass. If the @_routing@ mapping is defined, and set to be @required@, the index operation will fail if no routing value is provided or extracted.

h1. Parents &amp; Children

p. A child document can be indexed by specifying it's parent when indexing. For example:

<pre class="prettyprint">
$ curl -XPUT localhost:9200/blogs/blog_tag/1122?parent=1111 -d '{
    "tag" : "something"
}'
</pre>

p. When indexing a child document, the routing value is automatically set to be the same as it's parent, unless the routing value is explicitly specified using the @routing@ parameter. 

h1. Percolate

p. "Percolation":percolate.html can be performed at index time by passing the @percolate@ parameter. Setting it to @*@ will cause all percolation queries registered against the index to be checked against the provided document, for example:

<pre class="prettyprint">
curl -XPUT localhost:9200/test/type1/1?percolate=* -d '{
    "field1" : "value1"
}'
</pre>

p. To filter out which percolator queries will be executed, pass the query string syntax to the @percolate@ parameter:

<pre class="prettyprint">
curl -XPUT localhost:9200/test/type1/1?percolate=color:green -d '{
    "field1" : "value1",
    "field2" : "value2"
}'
</pre>

p. *NOTE:* In a distributed cluster, percolation during the index operation is performed on the primary shard, as soon as the index operation completes. The operation executes on the primary while the replicas are updating, concurrently. Percolation during the index operation somewhat cuts down on parsing overhead, as the parse tree for the document is simply re-used for percolation.

h1. Distributed

p. The index operation is directed to the primary shard based on it's route (see the Routing section above) and performed on the actual node containing this shard. After the primary shard completes the operation, if needed, the update is distributed to applicable replicas.

h1. Write Consistency

p. To prevent writes from taking place on the "wrong" side of a network partition, by default, index operations only succeed if a quorum (>replicas/2+1) of active shards are available. This default can be overridden on a node-by-node basis using the @action.write_consistency@ setting. To alter this behavior per-operation, the @consistency@ parameter can be used.

p. Valid write consistency values are @one@, @quorum@, and @all@.

h1. Asynchronous Replication

p. By default, the index operation only returns after the number of replicas controlled by write consistency have received the update. To enable asynchronous replication, causing the replication process to take place in the background, set the @replication@ parameter to @async@. When asynchronous replication is used, the index operation will return as soon as the operation succeeds on the primary shard.

h1. Refresh

p. To refresh the index immediately after the operation occurs, so that the document appears in search results immediately, the @refresh@ parameter can be set to @true@. Setting this option to @true@ should *ONLY* be done after careful thought and verification that it does not lead to poor performance, both from an indexing and a search standpoint.

h1. Timeout

p. The primary shard assigned to perform the index operation might not be available when the index operation is executed. Some reasons for this might be that the primary shard is currently recovering from a gateway or undergoing relocation. By default, the index operation will wait on the primary shard to become available for up to 1 minute before failing and responding with an error. The @timeout@ parameter can be used to explicitly specify how long it waits. Here is an example of setting it to 5 minutes:

<pre class="prettyprint">
$ curl -XPUT 'http://localhost:9200/twitter/tweet/1?timeout=5m' -d '{
    "user" : "kimchy",
    "post_date" : "2009-11-15T14:12:12",
    "message" : "trying out Elastic Search"
}'
</pre>

